{"data":{"markdownRemark":{"html":"<p><em>Note: This is where the Intermediate React course starts. All lessons from 16-22 on out are self-contained and always start from the <a href=\"https://github.com/btholt/complete-intro-to-react-v5\">master branch</a> of the git repository.</em></p>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/\">Open this CodeSandbox.</a> All of the examples are in there. We will not be using the code in project for this section, just this CodeSandbox.</p>\n<p>In the preceding course, we went over <code class=\"language-text\">useState</code>, <code class=\"language-text\">useEffect</code>, <code class=\"language-text\">useContext</code>, and <code class=\"language-text\">useRef</code>. These are the most common hooks and likely 99% of what you're going to use. However it's good to know what other tools are in your toolbox for the 1% of problems. We'll go through, example-by-example, and work out what all these hooks can do for you. (we'll review the ones we've talked about already too.)</p>\n<h2 id=\"usestate\"><a href=\"#usestate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useState</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FState.js\">Component</a>.</p>\n<p><code class=\"language-text\">useState</code> allows us to make our components stateful. Whereas this previously required using a class component, hooks give us the ability to write it using just functions. It allows us to have more flexible components. In our example component, everytime you click on the h1 (bad a11y, by the way) it'll change colors. It's doing this by keeping that bit of state in a hook which is being fed in anew every render so it always has the latest state.</p>\n<h2 id=\"useeffect\"><a href=\"#useeffect\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FEffect.js\">Component</a></p>\n<p>Effects are how you recreate <code class=\"language-text\">componentDidMount</code>, <code class=\"language-text\">componentDidUpdate</code>, and <code class=\"language-text\">componentDidUnmount</code> from React. Inside <code class=\"language-text\">useEffect</code>, you can do any sort of side-effect type action that you would have previously done in one of React's lifecycle methods. You can do things like fire AJAX requests, integrate with third party libraries (like a jQuery plugin), fire off some telemetry, or anything else that needs to happen on the side for your component.</p>\n<p>In our case, we want our component to continually update to show the time so we use setTimeout inside our effect. After the timeout calls the callback, it updates the state. After that render happens, it schedules another effect to happen, hence why it continues to update. You could provide a second parameter of <code class=\"language-text\">[]</code> to <code class=\"language-text\">useEffect</code> (after the function) which would make it only update once. This second array is a list of dependencies: only re-run this effect if one of these parameters changed. In our case, we want to run after every render so we don't give it this second parameter.</p>\n<h2 id=\"usecontext\"><a href=\"#usecontext\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useContext</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FContext.js\">Component</a></p>\n<p>An early problem with the React problem is called \"data tunneling\" or \"prop drilling\". This is when you have a top level component (in our case the parent component) and a child component way down in the hierarchy that need the same data (like the user object.) We could pass that data down, parent-to-child, for each of the intermediary components but that sucks because now each of <code class=\"language-text\">LevelTwo</code>, <code class=\"language-text\">LevelThree</code>, and <code class=\"language-text\">LevelFour</code> all have to know about the user object even when they themselves don't need it, just their children. This is prop drilling: passing down this data in unnecessary intermediaries.</p>\n<p>Enter context. Context allows you to create a wormhole where stuff goes in and a wormhole in a child component where that same data comes out and the stuff in the middle doesn't know it's there. Now that data is available anywhere inside of the <code class=\"language-text\">UserContext.Provider</code>. <code class=\"language-text\">useContext</code> just pulls that data out when given a Context object as a parameter. You don't have to use <code class=\"language-text\">useState</code> and <code class=\"language-text\">useContext</code> together (the data can be any shape, not just <code class=\"language-text\">useState</code>-shaped) but I find it convenient when child components need to be able to update the context as well.</p>\n<p>In general, context adds a decent amount of complexity to an app. A bit of prop drilling is fine. Only put things in context that are truly application-wide state like user information or auth keys and then use local state for the rest.</p>\n<p>Often you'll use context instead of Redux or another state store. You could get fancy and use <code class=\"language-text\">useReducer</code> and <code class=\"language-text\">useContext</code> together to get a pretty great approximation of Redux-like features.</p>\n<h2 id=\"useref\"><a href=\"#useref\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useRef</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FRef.js\">Component</a></p>\n<p>Refs are useful for several things, we'll explore two of the main reasons in these examples. I want to show you the first use case: how to emulate instance variables from React.</p>\n<p>In order to understand why refs are useful, you need to understand <a href=\"https://frontendmasters.com/courses/javascript-foundations/closure-introduction/\">how closures work</a>. In our component, when a user clicks, it sets a timeout to log both the state and the ref's number after a second. One thing to keep in mind that <strong>the state and the ref's number are always the same</strong>. They are never out of lockstep since they're updated at the same time. <em>However</em>, since we delay the logging for a second, when it alerts the new values, it will capture what the state was when we first called the timeout (since it's held on to by the closure) but it will always log the current value since that ref is on an object that React consistently gives the same object back to you.Â Because it's the same object and the number is a property on the object, it will always be up to date and not subject to the closure's scope.</p>\n<p>Why is this useful? It can be useful for things like holding on to <code class=\"language-text\">setInterval</code> and <code class=\"language-text\">setTimeout</code> IDs so they can be cleared later. Or any bit of statefulness that <em>could</em> change but you don't want it to cause a re-render when it does.</p>\n<p>It's also useful for referencing DOM nodes directly and we'll see that a bit later in this section.</p>\n<h2 id=\"usereducer\"><a href=\"#usereducer\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useReducer</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FReducer.js\">Component</a></p>\n<p>I'm going to assume you're familiar with Redux. If not, there's a brief section on it <a href=\"redux\">here</a>. <code class=\"language-text\">useReducer</code> allows us to do Redux-style reducers but inside a hook. Here, instead of having a bunch of functions to update our various properties, we have one reducer that handles all the updates based on an action type. This is a preferable approach if you have complex state updates or if you have a situation like this: all of the state updates are very similar so it makes sense to contain all of them in one function.</p>\n<h2 id=\"usememo\"><a href=\"#usememo\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FMemo.js\">Component</a></p>\n<p><code class=\"language-text\">useMemo</code> and <code class=\"language-text\">useCallback</code> are performance optimizations. Use them only when you already have a performance problem instead of pre-emptively. It adds unnecessary complexity otherwise.</p>\n<p><code class=\"language-text\">useMemo</code> memoizes expensive function calls so they only are re-evaluated when needed. I put in the <a href=\"https://en.wikipedia.org/wiki/Fibonacci_number\">fibonacci sequence</a> in its recursive style to simulate this. All you need to know is that once you're calling <code class=\"language-text\">fibonacci</code> with 30+ it gets quite computationally expensive and not something you want to do unnecessarily as it will cause pauses and jank. It will now only call <code class=\"language-text\">fibonacci</code> if count changes and will just the previous, memoized answer if it hasn't changed.</p>\n<p>If we didn't have the <code class=\"language-text\">useMemo</code> call, everytime I clicked on the title to cause the color to change from red to green or vice versa it'd unnecessarily recalculate the answer of <code class=\"language-text\">fibonacci</code> but because we did use <code class=\"language-text\">useMemo</code> it will only calculate it when <code class=\"language-text\">num</code> has changed.</p>\n<p>Feel try to remove <code class=\"language-text\">useMemo</code>, get <code class=\"language-text\">num</code> to 40 or so, and then click the h1. It'll be slow.</p>\n<h2 id=\"usecallback\"><a href=\"#usecallback\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FCallback.js\">Component</a></p>\n<p><code class=\"language-text\">useCallback</code> is quite similar and indeed it's implemented with the same mechanisms as <code class=\"language-text\">useMemo</code>. Our goal is that <code class=\"language-text\">ExpensiveComputationComponent</code> only re-renders whenever it absolutely must. Typically whenever React detects a change higher-up in an app, it re-renders everything underneath it. This normally isn't a big deal because React is quite fast at normal things. However you can run into performance issues sometimes where some components are bad to re-render without reason.</p>\n<p>In this case, we're using a new feature of React called <code class=\"language-text\">React.memo</code>. This is similar to <code class=\"language-text\">PureComponent</code> where a component will do a simple check on its props to see if they've changed and if not it will not re-render this component (or its children, which can bite you.) <code class=\"language-text\">React.memo</code> provides this functionality for function components. Given that, we need to make sure that the function itself given to <code class=\"language-text\">ExpensiveComputationComponent</code> is the <em>same</em> function every time. We can use <code class=\"language-text\">useCallback</code> to make sure that React is handing <em>the same fibonacci</em> to <code class=\"language-text\">ExpensiveComputationComponent</code> every time so it passes its <code class=\"language-text\">React.memo</code> check every single time. Now it's only if <code class=\"language-text\">count</code> changes will it actually re-render (as evidenced by the time.)</p>\n<p>Try removing the useCallback call and see if you get the the count to 40+ that the page crawls as it updates every second.</p>\n<h2 id=\"uselayouteffect\"><a href=\"#uselayouteffect\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useLayoutEffect</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FLayoutEffect.js\">Component</a></p>\n<p><code class=\"language-text\">useLayoutEffect</code> is almost the same as <code class=\"language-text\">useEffect</code> except that it's synchronous to render as opposed to scheduled like <code class=\"language-text\">useEffect</code> is. If you're migrating from a class component to a hooks-using function component, this can be helpful too because <code class=\"language-text\">useLayout</code> runs at the same time as <code class=\"language-text\">componentDidMount</code> and <code class=\"language-text\">componentDidUpdate</code> whereas <code class=\"language-text\">useEffect</code> is scheduled after. This should be a temporary fix.</p>\n<p>The only time you <em>should</em> be using <code class=\"language-text\">useLayoutEffect</code> is to measure DOM nodes for things like animations. In the example, I measure the textarea after every time you click on it (the onClick is to force a re-render.) This means you're running render twice but it's also necessary to be able to capture the correct measurments.</p>\n<h2 id=\"useimperativehandle\"><a href=\"#useimperativehandle\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useImperativeHandle</h2>\n<p><a href=\"https://codesandbox.io/s/github/btholt/react-hooks-examples/tree/master/?module=%2Fsrc%2FImperativeHandle.js\">Component</a></p>\n<p>Here's one you will likely never directly use but you may use libraries that use it for you. We're going to use it in conjunction with another feature called <code class=\"language-text\">forwardRef</code> that again, you probably won't use but libraries will use on your behalf. Let's explain first what it does using the example and then we'll explain the moving parts.</p>\n<p>In the example above, whenever you have an <em>invalid</em> form, it will immediately focus the the first field that's invalid. If you look at the code, <code class=\"language-text\">ElaborateInput</code> is a child element so the parent component shouldn't have any access to the input contained inside the component. Those components are black boxes to their parents. All they can do is pass in props. So how do we accomplish it then?</p>\n<p>The first thing we use is <code class=\"language-text\">useImperativeHandle</code>. This allows us to customize methods on an object that is made available to the parents via the <code class=\"language-text\">useRef</code> API. Inside <code class=\"language-text\">ElaborateInput</code> we have two refs: one thate is the one that will be provided by the parent, forwarded through by wrapping the <code class=\"language-text\">ElaborateInput</code> component in a <code class=\"language-text\">forwardRef</code> call which will ten provide that second <code class=\"language-text\">ref</code> parameter in the function call, and then the <code class=\"language-text\">inputRef</code> which is being used to directly access the DOM so we can call <code class=\"language-text\">focus</code> on the DOM node directly.</p>\n<p>From the parent, we assign via <code class=\"language-text\">useRef</code> a ref to each of the <code class=\"language-text\">ElaborateInput</code>s which is then forwarded on each on via the <code class=\"language-text\">forwardRef</code>. Now, on these refs inside the parent component we have those methods that we made inside the child so we can call them when we need to. In this case, we'll calling the focus when the parent knows that the child has an error.</p>\n<p>Again, you probably use this directly but it's good to know it exists. Normally it's better to not use this hook and try to accomplish the same thing via props but sometimes it may be useful to break this one out.</p>","frontmatter":{"path":"/hooks-in-depth","title":"Hooks in Depth","order":16}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/pure-react","title":"Pure React"}}},{"node":{"frontmatter":{"order":3,"path":"/eslint-prettier","title":"npm, ESLint & Prettier"}}},{"node":{"frontmatter":{"order":4,"path":"/parcel","title":"Parcel"}}},{"node":{"frontmatter":{"order":5,"path":"/jsx","title":"JSX"}}},{"node":{"frontmatter":{"order":6,"path":"/hooks","title":"Hooks"}}},{"node":{"frontmatter":{"order":7,"path":"/effects","title":"Effects"}}},{"node":{"frontmatter":{"order":8,"path":"/dev-tools","title":"Dev Tools"}}},{"node":{"frontmatter":{"order":9,"path":"/async","title":"Handling Async"}}},{"node":{"frontmatter":{"order":10,"path":"/reach-router","title":"Reach Router"}}},{"node":{"frontmatter":{"order":11,"path":"/class-components","title":"Class Components"}}},{"node":{"frontmatter":{"order":12,"path":"/error-boundaries","title":"Error Boundaries"}}},{"node":{"frontmatter":{"order":13,"path":"/context","title":"Context"}}},{"node":{"frontmatter":{"order":14,"path":"/portals-and-refs","title":"Portals and Refs"}}},{"node":{"frontmatter":{"order":15,"path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":16,"path":"/hooks-in-depth","title":"Hooks in Depth"}}},{"node":{"frontmatter":{"order":17,"path":"/emotion","title":"Emotion"}}},{"node":{"frontmatter":{"order":19,"path":"/code-splitting","title":"Code Splitting"}}},{"node":{"frontmatter":{"order":19,"path":"/typescript","title":"TypeScript"}}},{"node":{"frontmatter":{"order":20,"path":"/ssr","title":"Server Side Rendering"}}},{"node":{"frontmatter":{"order":21,"path":"/redux","title":"Redux"}}},{"node":{"frontmatter":{"order":22,"path":"/testing","title":"Testing"}}}]}},"pageContext":{}}